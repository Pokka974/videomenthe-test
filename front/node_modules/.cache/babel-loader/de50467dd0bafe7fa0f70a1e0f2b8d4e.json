{"ast":null,"code":"// @ts-check\n// @deno-types=\"is-plain-obj/index.d.ts\"\nimport isPlainObject from \"is-plain-obj\";\n/** @typedef {import(\"./isExtractableFile.mjs\").default} isExtractableFile */\n\n/**\n * Recursively extracts files and their {@link ObjectPath object paths} within a\n * value, replacing them with `null` in a deep clone without mutating the\n * original value.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist)\n * instances are treated as\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) instance\n * arrays.\n * @template Extractable Extractable file type.\n * @param {unknown} value Value to extract files from. Typically an object tree.\n * @param {(value: unknown) => value is Extractable} isExtractable Matches extractable files. Typically\n *   {@linkcode isExtractableFile}.\n * @param {ObjectPath} [path] Prefix for object paths for extracted files.\n *   Defaults to `\"\"`.\n * @returns {Extraction<Extractable>} Extraction result.\n * @example\n * Extracting files from an object.\n *\n * For the following:\n *\n * ```js\n * import extractFiles from \"extract-files/extractFiles.mjs\";\n * import isExtractableFile from \"extract-files/isExtractableFile.mjs\";\n *\n * const file1 = new File([\"1\"], \"1.txt\", { type: \"text/plain\" });\n * const file2 = new File([\"2\"], \"2.txt\", { type: \"text/plain\" });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, isExtractableFile, \"prefix\");\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `[\"prefix.a\", \"prefix.b.0\"]` |\n * | `file2` | `[\"prefix.b.1\"]`             |\n */\n\nexport default function extractFiles(value, isExtractable) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  if (!arguments.length) throw new TypeError(\"Argument 1 `value` is required.\");\n  if (typeof isExtractable !== \"function\") throw new TypeError(\"Argument 2 `isExtractable` must be a function.\");\n  if (typeof path !== \"string\") throw new TypeError(\"Argument 3 `path` must be a string.\");\n  /**\n   * Deeply clonable value.\n   * @typedef {Array<unknown> | FileList | Record<PropertyKey, unknown>} Cloneable\n   */\n\n  /**\n   * Clone of a {@link Cloneable deeply cloneable value}.\n   * @typedef {Exclude<Cloneable, FileList>} Clone\n   */\n\n  /**\n   * Map of values recursed within the input value and their clones, for reusing\n   * clones of values that are referenced multiple times within the input value.\n   * @type {Map<Cloneable, Clone>}\n   */\n\n  const clones = new Map();\n  /**\n   * Extracted files and their object paths within the input value.\n   * @type {Extraction<Extractable>[\"files\"]}\n   */\n\n  const files = new Map();\n  /**\n   * Recursively clones the value, extracting files.\n   * @param {unknown} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set<Cloneable>} recursed Recursed values for avoiding infinite\n   *   recursion of circular references within the input value.\n   * @returns {unknown} Clone of the value with files replaced with `null`.\n   */\n\n  function recurse(value, path, recursed) {\n    if (isExtractable(value)) {\n      const filePaths = files.get(value);\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n      return null;\n    }\n\n    const valueIsList = Array.isArray(value) || typeof FileList !== \"undefined\" && value instanceof FileList;\n    const valueIsPlainObject = isPlainObject(value);\n\n    if (valueIsList || valueIsPlainObject) {\n      let clone = clones.get(value);\n      const uncloned = !clone;\n\n      if (uncloned) {\n        clone = valueIsList ? [] : // Replicate if the plain object is an `Object` instance.\n        value instanceof\n        /** @type {any} */\n        Object ? {} : Object.create(null);\n        clones.set(value,\n        /** @type {Clone} */\n        clone);\n      }\n\n      if (!recursed.has(value)) {\n        const pathPrefix = path ? `${path}.` : \"\";\n        const recursedDeeper = new Set(recursed).add(value);\n\n        if (valueIsList) {\n          let index = 0;\n\n          for (const item of value) {\n            const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);\n            if (uncloned)\n              /** @type {Array<unknown>} */\n              clone.push(itemClone);\n          }\n        } else for (const key in value) {\n          const propertyClone = recurse(value[key], pathPrefix + key, recursedDeeper);\n          if (uncloned)\n            /** @type {Record<PropertyKey, unknown>} */\n            clone[key] = propertyClone;\n        }\n      }\n\n      return clone;\n    }\n\n    return value;\n  }\n\n  return {\n    clone: recurse(value, path, new Set()),\n    files\n  };\n}\n/**\n * An extraction result.\n * @template [Extractable=unknown] Extractable file type.\n * @typedef {object} Extraction\n * @prop {unknown} clone Clone of the original value with extracted files\n *   recursively replaced with `null`.\n * @prop {Map<Extractable, Array<ObjectPath>>} files Extracted files and their\n *   object paths within the original value.\n */\n\n/**\n * String notation for the path to a node in an object tree.\n * @typedef {string} ObjectPath\n * @see [`object-path` on npm](https://npm.im/object-path).\n * @example\n * An object path for object property `a`, array index `0`, object property `b`:\n *\n * ```\n * a.0.b\n * ```\n */","map":{"version":3,"sources":["C:/Users/Pokka/Desktop/DEV/videomenthe-test/front/node_modules/extract-files/extractFiles.mjs"],"names":["isPlainObject","extractFiles","value","isExtractable","path","arguments","length","TypeError","clones","Map","files","recurse","recursed","filePaths","get","push","set","valueIsList","Array","isArray","FileList","valueIsPlainObject","clone","uncloned","Object","create","has","pathPrefix","recursedDeeper","Set","add","index","item","itemClone","key","propertyClone"],"mappings":"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","sourcesContent":["// @ts-check\n\n// @deno-types=\"is-plain-obj/index.d.ts\"\nimport isPlainObject from \"is-plain-obj\";\n\n/** @typedef {import(\"./isExtractableFile.mjs\").default} isExtractableFile */\n\n/**\n * Recursively extracts files and their {@link ObjectPath object paths} within a\n * value, replacing them with `null` in a deep clone without mutating the\n * original value.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist)\n * instances are treated as\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) instance\n * arrays.\n * @template Extractable Extractable file type.\n * @param {unknown} value Value to extract files from. Typically an object tree.\n * @param {(value: unknown) => value is Extractable} isExtractable Matches extractable files. Typically\n *   {@linkcode isExtractableFile}.\n * @param {ObjectPath} [path] Prefix for object paths for extracted files.\n *   Defaults to `\"\"`.\n * @returns {Extraction<Extractable>} Extraction result.\n * @example\n * Extracting files from an object.\n *\n * For the following:\n *\n * ```js\n * import extractFiles from \"extract-files/extractFiles.mjs\";\n * import isExtractableFile from \"extract-files/isExtractableFile.mjs\";\n *\n * const file1 = new File([\"1\"], \"1.txt\", { type: \"text/plain\" });\n * const file2 = new File([\"2\"], \"2.txt\", { type: \"text/plain\" });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, isExtractableFile, \"prefix\");\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `[\"prefix.a\", \"prefix.b.0\"]` |\n * | `file2` | `[\"prefix.b.1\"]`             |\n */\nexport default function extractFiles(value, isExtractable, path = \"\") {\n  if (!arguments.length) throw new TypeError(\"Argument 1 `value` is required.\");\n\n  if (typeof isExtractable !== \"function\")\n    throw new TypeError(\"Argument 2 `isExtractable` must be a function.\");\n\n  if (typeof path !== \"string\")\n    throw new TypeError(\"Argument 3 `path` must be a string.\");\n\n  /**\n   * Deeply clonable value.\n   * @typedef {Array<unknown> | FileList | Record<PropertyKey, unknown>} Cloneable\n   */\n\n  /**\n   * Clone of a {@link Cloneable deeply cloneable value}.\n   * @typedef {Exclude<Cloneable, FileList>} Clone\n   */\n\n  /**\n   * Map of values recursed within the input value and their clones, for reusing\n   * clones of values that are referenced multiple times within the input value.\n   * @type {Map<Cloneable, Clone>}\n   */\n  const clones = new Map();\n\n  /**\n   * Extracted files and their object paths within the input value.\n   * @type {Extraction<Extractable>[\"files\"]}\n   */\n  const files = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @param {unknown} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set<Cloneable>} recursed Recursed values for avoiding infinite\n   *   recursion of circular references within the input value.\n   * @returns {unknown} Clone of the value with files replaced with `null`.\n   */\n  function recurse(value, path, recursed) {\n    if (isExtractable(value)) {\n      const filePaths = files.get(value);\n\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n\n      return null;\n    }\n\n    const valueIsList =\n      Array.isArray(value) ||\n      (typeof FileList !== \"undefined\" && value instanceof FileList);\n    const valueIsPlainObject = isPlainObject(value);\n\n    if (valueIsList || valueIsPlainObject) {\n      let clone = clones.get(value);\n\n      const uncloned = !clone;\n\n      if (uncloned) {\n        clone = valueIsList\n          ? []\n          : // Replicate if the plain object is an `Object` instance.\n          value instanceof /** @type {any} */ (Object)\n          ? {}\n          : Object.create(null);\n\n        clones.set(value, /** @type {Clone} */ (clone));\n      }\n\n      if (!recursed.has(value)) {\n        const pathPrefix = path ? `${path}.` : \"\";\n        const recursedDeeper = new Set(recursed).add(value);\n\n        if (valueIsList) {\n          let index = 0;\n\n          for (const item of value) {\n            const itemClone = recurse(\n              item,\n              pathPrefix + index++,\n              recursedDeeper\n            );\n\n            if (uncloned) /** @type {Array<unknown>} */ (clone).push(itemClone);\n          }\n        } else\n          for (const key in value) {\n            const propertyClone = recurse(\n              value[key],\n              pathPrefix + key,\n              recursedDeeper\n            );\n\n            if (uncloned)\n              /** @type {Record<PropertyKey, unknown>} */ (clone)[key] =\n                propertyClone;\n          }\n      }\n\n      return clone;\n    }\n\n    return value;\n  }\n\n  return {\n    clone: recurse(value, path, new Set()),\n    files,\n  };\n}\n\n/**\n * An extraction result.\n * @template [Extractable=unknown] Extractable file type.\n * @typedef {object} Extraction\n * @prop {unknown} clone Clone of the original value with extracted files\n *   recursively replaced with `null`.\n * @prop {Map<Extractable, Array<ObjectPath>>} files Extracted files and their\n *   object paths within the original value.\n */\n\n/**\n * String notation for the path to a node in an object tree.\n * @typedef {string} ObjectPath\n * @see [`object-path` on npm](https://npm.im/object-path).\n * @example\n * An object path for object property `a`, array index `0`, object property `b`:\n *\n * ```\n * a.0.b\n * ```\n */\n"]},"metadata":{},"sourceType":"module"}